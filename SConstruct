# Copyright (C) 2010-2011, Christian Meesters (meesters@uni-mainz.de)
# This code is part of the ngs distribution and governed by its
# license.  Please see the LICENSE file that should have been included
# as part of this package.

# $Rev: 940 $
# $LastChangedDate: 2014-08-30 12:57:41 +0200 (Sa, 30 Aug 2014) $ # date of last revision
# $Author: meesters $

from datetime import datetime
import fnmatch
import hashlib
import zipfile
import tarfile
import platform
import subprocess
import os
import glob
import re
import shutil
import tempfile
import warnings
import sys

os.nice(10)

# shortcut
LS = os.linesep

VERSION = ("0", "1", "0")
VERSIONSTRING = '.'.join(VERSION)
DATE    = datetime.today().strftime("%d. %b %Y")

def write_doxygencfg():
    tmpfname = tempfile.mktemp()
    tmpfile = open(tmpfname, 'w')
    infile  = open("doxygen_ngs.cfg")
    for line in infile:
	if "PROJECT_NUMBER" in line:
            tmpfile.write("PROJECT_NUMBER = %s" % VERSIONSTRING)
	    tmpfile.write(os.linesep)
	else:
            tmpfile.write(line)
    infile.close()
    tmpfile.close()
    shutil.move(tmpfname, 'doxygen_ngs.cfg')

def write_versionheader():
    """
       will write the version header file,
       just before compilation
    """
    # gcc version tuple
    gcc_version = ','.join(['__GNUC__', '__GNUC_MINOR__', '__GNUC_PATCHLEVEL__'])

    versionfile = open('./trunk/include/ngs_version.hpp', 'w')
    versionfile.write("// This file is automatically generated -- do not try to change it." + LS)
    versionfile.write("// The NGSPREPROC license applies." + LS + LS)
    versionfile.write("#include \"boost/tuple/tuple.hpp\"%s" % LS)
    versionfile.write("#include <string> %s" % LS)
    versionfile.write("#include <map> %s" % LS)
    versionfile.write("// ngs version tuple: major, minor, bug fix %s" % LS)
    versionfile.write("typedef boost::tuple<int, int, int> version;%s" % LS)
    versionfile.write("#ifdef __GNUC__ %s  typedef boost::tuple<int, int, int> gcc_version;%s#endif%s" % (LS, LS, LS))
    versionfile.write(LS)
    versionfile.write('namespace ngs {%s \
    const version VERSION(%s);%s \
    const std::string DATE(\" %s\");%s \
    #ifdef __GNUC__ %s\
      const gcc_version GCC_VERSION(%s);%s \
    #endif %s\
} // end namespace ngs%s' % (LS, ','.join(VERSION), LS, DATE, LS, LS, gcc_version, LS, LS, LS))

def check_gcc_version():
    g_comp = GetOption('CXX')
    ret = subprocess.Popen(['%s --version' % g_comp], 
                           stdout = subprocess.PIPE,
                           stderr = subprocess.PIPE, 
                           shell = True).communicate()[0]
    version_string = re.search(r'\d\.\d\.\d', ret).group()
    return tuple(map(int, version_string.split('.')))

Help("""
       ngs build setup
       Type: 'scons'                to build the production program,
             'scons --debug_build'  to build the debug version with gcc profiling,
             'scons --pack_release' to build and package the release version,
             'scons --doxygen'      to call doxygen (only if doxygen is present),
             'scons --static'       to statically link the program,
             'scons --compiler=<compiler>' to activly choose a different compiler,
             'scons --include_production' to set the INCLUDE_PRODUCTION flag,
             'scons --sandbox'            to set the SANDBOX flag,
             'scons --lib'          to alter the LIBRARY_PATH on the fly.
       Using '-j x', where 'x' is the number of processes to use,
       enables parallel building.
       """)

src_files = Glob('trunk/src/*cpp')

AddOption('--debug_build',
          dest    = 'ngs_debug',
          action  = 'store_true',
          default = False,
          help    = 'build a debug version')

AddOption('--pack_release',
          dest    = 'pack_release',
          action  = 'store_true',
          default = False,
          help    = 'build and pack a release to be shipped')

AddOption('--doxygen',
          dest    = 'doxygen',
	  action  = 'store_true',
	  default = False,
	  help    = 'replaces the doxygen.cfg file and calls doxygen')

AddOption('--vtune',
          dest    = 'vtune',
          action  = 'store_true',
          default = False,
          help    = 'options to work with vtune')
AddOption('--allinea',
          dest    = 'allinea',
          action  = 'store_true',
          default = False,
          help    = 'options to work with map')

AddOption('--static',
          dest    = 'static',
          action  = 'store_true',
	  default = False)
AddOption('--test',
          dest    = 'test',
	  action  = 'store_true',
	  default = False)
AddOption('--test_debug',
          dest    = 'testdebug',
	  action  = 'store_true',
	  default = False)
AddOption('--test_memory',
          dest    = 'testmemory',
          action  = 'store_true',
          default = False,
          help    = 'turns on memory profiling for gcc on some(!) Linux systems')
AddOption('--compiler',
          dest    = 'CXX',
          default = 'g++')
AddOption('--libpath',
          dest    = 'lib')
AddOption('--sandbox',
          action  = 'store_true',
          default = False,
          dest    = 'sandbox',
          help    = "will include sandboxed code, currently demands the MGL library")
AddOption('--include_production',
          action  = 'store_true',
          default = False,
          dest    = 'include_production',
          help    = "will include all production code, including LD-blockwise algorithm")
AddOption('--timer',
          action  = 'store_true',
          default = False,
          dest    = 'timer',
          help    = "will enable timings")

opt = Environment(ENV  = os.environ,
                  PATH = os.environ['PATH'],
                  TERM = os.environ['TERM'],
                  HOME = os.environ['HOME'],
                  CXX  = GetOption('CXX'))

if GetOption('doxygen'):
   write_doxygencfg()
   subprocess.call('doxygen doxygen_ngs.cfg', shell = True)
   sys.exit()

# configure C++11 support for g++
C11 = "-std=c++0x"
if check_gcc_version() >= (4, 7):
   C11 = "-std=c++11"
   #C11 = "-std=gnu++11"

if GetOption('ngs_debug'):
   opt.Append(LINKFLAGS = ['-fopenmp', '-pg'])
   ccflags = ['-fopenmp', '-Wall', '-Wuninitialized',
              '-g',         # let the program write GNU debugger output
              '-pg',        # enables profiling
              '-O0',        # should be running as if in release mode
              '-march=native',
              C11,          # C11 compliance
	      '-DDEBUG']    # sets the DEBUG-flag for the preprocessor
elif GetOption('vtune'):
   opt.Append(LINKFLAGS = ['-fopenmp', '-g', '-pg'])
   ccflags = ['-fopenmp', '-Wall', '-Wuninitialized', 
              '-g',         # let the program write GNU debugger output
              '-pg',        # enables profiling
              '-O3',        # should be running as if in release mode
              '-march=native',
              C11          # C11 compliance
              ]



elif GetOption('allinea'):
   opt.Append(LINKFLAGS = ['-fopenmp', '-g'])
   ccflags = ['-fopenmp', '-Wall', '-Wuninitialized',
              '-g',         # let the program write GNU debugger output
              #'-pg',        # enables profiling
              '-O0',
              '-march=native',
              C11 ,         # C11 compliance
	      '-DDEBUG'    # sets the DEBUG-flag for the preprocessor
            ]



elif GetOption('pack_release'): # in this case a static executable is handy
   opt.Append(LINKFLAGS = ['-fopenmp', '-static'])
   ccflags = ['-fopenmp', '-O3', '-Wall', '-ansi', '-pedantic', '-Wuninitialized',
               C11]
elif GetOption('testdebug'):
   opt.Append(LINKFLAGS = ['-fopenmp', '-pg'])
   ccflags = ['-fopenmp', '-O0', '-Wall', '-ansi', '-pedantic', '-Wuninitialized',
              C11, '-DTEST', '-DDEBUG', '-g', '-pg']
else:
   opt.Append(LINKFLAGS = ['-fopenmp'])
   ccflags = ['-fopenmp', 
   '-O3',
   '-march=native',
   #'-O3', '-ftree-vectorizer-verbose=2', 
   '-Wall', '-ansi', '-pedantic', '-Wuninitialized',
               C11]

if GetOption('sandbox'):
   ccflags.append('-DSANDBOX')
if GetOption('timer'):
   ccflags.append('-DTIMER')
if GetOption('include_production'):
   ccflags.append('-DINCLUDEPRODUCTION')
if GetOption('testmemory'):
   ccflags.append('-DMEMORY')
if GetOption('test'):
   ccflags.append('-DTEST')

if GetOption('static'):
   opt.Append(LINKFLAGS = ['-static'])
   #ccflags.append('-DSIMULATION')
if GetOption('lib'):
   try:
       LIBPATH = os.environ['LIBRARY_PATH']
       LIBPATH.append(GetOption('lib'))
   except KeyError:
       LIBPATH = []
else:
   try:
       LIBPATH = os.environ['LIBRARY_PATH']
   except KeyError:
       LIBPATH = []

if __name__ == "SCons.Script": 
    # check whether minimum gcc version is supported on this machine
    # if g++ is actually installed
    if 'g++' in GetOption('CXX'): 
        if not check_gcc_version() >= (4, 4):
            raise AssertionError("ngs requires g++ >= 4.4 to compile")
    else:
        warnings.warn("Assuming compiler != g++. Please ensure that OpenMP 3 is supported.")
    write_versionheader()

    # Decide whether file has changed and needs rebuilding in the
    # development process
    Decider('MD5') # default is md5
    
    opt.Program(target  = './ngs', 
                source  = src_files, 
                CCFLAGS = ccflags, 
                LIBPATH = LIBPATH,
                LIBS    = ['libboost_program_options',
                           'libboost_iostreams',
                           'libboost_system',
		           'libboost_regex',
                           #'mgl',
                           'png',
                           'z'])

    if GetOption('pack_release'):
        print "Packing release"
    
        # create 'dist' directory
        try:
            os.mkdir('dist')
        except OSError: pass
        os.chdir('dist')

        ARCHITECTURE = platform.architecture()[0]
        SYSTEM       = platform.system()

        # list of tuples: (location, naming after unpacking)
        file_list = [('../ngs', './ngs_%s/ngs' % VERSIONSTRING),
                     ('../LICENSE', './ngs_%s/LICENSE' % VERSIONSTRING),
                     ('../INSTALL', './ngs_%s/INSTALL' % VERSIONSTRING),
                     ('../examples/README', './ngs_%s/examples/README' % VERSIONSTRING),
                     ('../doc/Manual.pdf', './ngs_%s/doc/Manual.pdf' % VERSIONSTRING)]

        # first make source distro
        sourcetarfname = 'ngs_%s_source.tar' % VERSIONSTRING
        cppdir   = '../trunk/src'
        libdir   = '../trunk/include'
        curdir   = os.getcwd()
        t = tarfile.TarFile(sourcetarfname, 'w')
        
        # add actual sources
        os.chdir(cppdir)
        for fname in glob.glob('*cpp'):
            t.add(fname, "./ngs_%s/trunk/src/%s" % (VERSIONSTRING, fname))
        os.chdir(curdir)

        # add header files
        os.chdir(libdir)
        for fname in glob.glob('*hpp'):
            t.add(fname, "./ngs_%s/trunk/include/%s" % (VERSIONSTRING, fname))
        os.chdir(curdir)
        for fname in glob.glob('../utilities/*'):
            tail = os.path.split(fname)[-1]
            t.add(fname, "./ngs_%s/utilities/%s" % (VERSIONSTRING, tail))
        for fname in glob.glob('../doc/*.tex'):
            tail = os.path.split(fname)[-1]
            t.add(fname, "./ngs_%s/doc/%s" % (VERSIONSTRING, tail))
        t.add('../doc/Manual.pdf', "./ngs_%s/doc/Manual.pdf" % VERSIONSTRING)
        for fname in ['../doxygen_ngs.cfg', '../LICENSE', '../SConstruct', '../INSTALL']:
            tail = os.path.split(fname)[-1]
            t.add(fname, "./ngs_%s/%s" % (VERSIONSTRING, tail))
        t.close()
        subprocess.call(['gzip', '-f9', sourcetarfname])

        buildzipfname = 'ngs_%s_%s_%s.zip' % (ARCHITECTURE, SYSTEM, VERSIONSTRING)
        z = zipfile.ZipFile(buildzipfname, 'w', compression = zipfile.ZIP_DEFLATED)
        for item in file_list:
            z.write(item[0], item[1])
        z.close()

        if platform.system() == 'Linux':
            buildtarfname = 'ngs_%s_%s_%s.tar' % (ARCHITECTURE, SYSTEM, VERSIONSTRING)
            t = tarfile.TarFile(buildtarfname, 'w')
            for item in file_list:
                t.add(item[0], item[1])
            t.close()
            subprocess.call(['gzip', '-f9', buildtarfname])

        # calculate md5sums
        print "Calculating md5sums"
        sep = os.linesep
        md5file = open("md5sums.txt", 'a')
        md5file.write("Source distribution: ")
        content = open("%s.gz" % sourcetarfname).read()
        md5source = hashlib.md5()
        md5source.update(content)
        md5file.write(md5source.hexdigest() + sep)
        md5file.write("Zipfile %s: " % buildzipfname)
        content = open(buildzipfname).read()
        md5zip = hashlib.md5()
        md5zip.update(content)
        md5file.write(md5zip.hexdigest() + sep)
        md5file.write("Tarfile %s.gz: " % buildtarfname)
        content = open("%s.gz" % buildtarfname).read()
        md5tar = hashlib.md5()
        md5tar.update(content)
        md5file.write(md5tar.hexdigest() + sep)

        md5file.close()
        print     

        os.chdir('../')
        print "Finished packing release"
        sys.exit()
    
